# -*- coding: utf-8 -*-
"""Untitled (1).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1bqH8KVMNUK5fXmxVxZrvJ4FeYDMzHpRH
"""

from google.colab import files
files.upload()

!pip install catboost
import pandas as pd
import matplotlib.pyplot as plt
import plotly.express as px
import seaborn as sns
import matplotlib.pyplot as plt
import numpy as np
from prophet import Prophet
from tqdm.notebook import trange, tqdm
from pandas import Series
from matplotlib import pyplot
from statsmodels.tsa.seasonal import seasonal_decompose
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from catboost import CatBoostRegressor
from sklearn.metrics import mean_absolute_error
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_squared_error
from prophet.plot import plot_plotly, plot_components_plotly
from statsmodels.api import datasets

data_train = pd.read_csv('dataset_for_technical_assessment.csv')
display(data_train.head())
data_train.info()

data_train.isnull().sum().sort_values(ascending=False)

data_train = data_train.dropna().reset_index(drop=True)

data_train.Description = pd.to_datetime(data_train.Description)

df1 = data_train.melt(id_vars=['Description'], var_name = 'val').query("val in ['y1', 'y2']")
px.line(df1, x='Description', y='value', color='val' ).show()

data_train['y'] = data_train['y1'] + data_train['y2']
fig = px.line(data_train, x='Description', y="y", title='y1 + y2')
fig.show()

def group(row): 
    
    if row['y'] > 1:
        return (row['y1'] + row['y2']) / 2

    return row['y']
data_train['y'] = data_train.apply(group, axis=1) # create a column with the received values

fig = px.line(data_train, x='Description', y="y", title='y1 + y2')
fig.show()

fig = px.box(data_train, y="y", title='y1 + y2')
fig.show()

data_train = data_train.query('y < 0.921 and y > 0.6')

data_train = data_train.drop(['y1', 'y2'], axis=1)

plt.figure(figsize=(15, 10)) 

mask = np.triu(np.ones_like(data_train.corr(), dtype=np.bool)) 
heatmap = sns.heatmap(data_train.corr(), mask=mask, vmin=-1, vmax=1, annot=True, cmap='BrBG') 
heatmap.set_title('Triangle Correlation Heatmap', fontdict={'fontsize':25}, pad=20);

data_train['x23'] = (data_train['x2'] + data_train['x3']) / 2
data_train = data_train.drop(['x2', 'x3'], axis=1)


data_train = data_train.drop('x4', axis=1)

df1 = data_train.melt(id_vars=['Description'], var_name = 'val').query("val in ['x1', 'x23', 'x5', 'x6','x7','x8']")
p = px.line(df1, x='Description', y='value', color='val' )
p.show()

df = data_train.groupby(pd.Grouper(key="Description", freq="h")).sum()
df

fig = px.box(df.query('y < 11 and y > 7.5'), y="y", title='y1 + y2')
fig.show()

df = df.query('y < 11 and y > 7.5')

fig = px.line(df, x=df.index, y="y", title='y1 + y2')
fig.show()

df = data_train.groupby(pd.Grouper(key="Description", freq="h")).sum()
df = df.query('y < 11 and y > 7.5')
df = df.rename(columns = {'index':'Description'})
df.reset_index(inplace=True)
# del data
data = df[['Description', 'y']]
data.rename(columns = {'Description' : 'ds'}, inplace = True)
data

# Commented out IPython magic to ensure Python compatibility.
# %%time
# 
# wrong = pd.DataFrame({
# 'holiday': 'wrong',
# 'ds': pd.to_datetime(['2017-05-02', '2017-05-03', '2017-05-04', '2017-05-05', '2017-05-06', '2017-05-07', '2017-05-08']),
# 'lower_window': -1,
# 'upper_window': 1,
# })
# 
# m = Prophet(holidays = wrong,
#             growth="linear", 
#             daily_seasonality=True, 
#             yearly_seasonality = False,
#             weekly_seasonality = False,
#             seasonality_mode = "multiplicative",
#             changepoint_prior_scale = 0.1,
#             seasonality_prior_scale = 35
#             )
# 
# m.add_seasonality(name="monthly",period=30, fourier_order = 3)
# m.add_seasonality(name="weekly",
#                                 period = 7,
#                                 fourier_order = 40)
# # m.add_seasonality(name="yearly", 
# #                                 period=365.25,
# #                                 fourier_order = 35)
# m.add_seasonality(name="quarter",
#                                 period=365.25 / 4,
#                                 fourier_order = 5,
#                                 prior_scale = 5)
# m.add_seasonality(name="1/2year",
#                                 period=365.25 / 2,
#                                 fourier_order = 5,
#                                 prior_scale = 5)
# # m.add_country_holidays(country_name = 'US')
# 
# m.fit(data)
# future = m.make_future_dataframe(periods= 14*24, freq='h',  include_history = False)
# forecast1 = m.predict(future)
# 
# forecast1[['ds', 'yhat', 'yhat_lower', 'yhat_upper']]

fig2 = m.plot_components(forecast1)

plot_plotly(m, forecast1)

forecastdf = forecast1[['ds', 'yhat']].rename(columns = {'ds':'Description', 'yhat': 'y'})
data = pd.concat([df, forecastdf])
data

data = data.groupby(pd.Grouper(key="Description", freq="h")).sum()
data = data.rename(columns = {'index':'Description'})
data

for i in trange(1, len(df.columns)):
    if df.columns[i] != 'y':
        print(df.columns[i])

def make_features(data, max_lag, rolling_mean_size):
     # four new calendar attributes: year, month, day and day of the week
    data['year'] = data.index.year
    data['month'] = data.index.month
    data['day'] = data.index.day
    data['dayofweek'] = data.index.dayofweek
    
    # lagging values. max_lag, which will set the maximum lag size.
    for i in trange(1, len(df.columns)):
        for lag in range(1, max_lag + 1):
            if df.columns[i] != 'y':
                data['lag_{}'.format(lag)] = data[df.columns[i]].shift(lag)

    # moving average
    # data['rolling_mean'] = data['x1'].shift().rolling(rolling_mean_size).mean()

make_features(data, 14*24, 5)
data

data_split = data[:-(14*24)]
test = data[-(14*24):]
train, valid = np.split(data.sample(frac=1, random_state=12345),
                                 [int(.85*len(data))])

train = train.dropna()
valid = valid.dropna()
test = test.dropna()
# variables for features and target feature
features_train = train.drop(['y'], axis=1)
target_train = train['y']

features_valid = valid.drop(['y'], axis=1)
target_valid = valid['y']

features_test = test.drop(['y'], axis=1)
target_test = test['y']
print(train.shape)
print(valid.shape)
print(test.shape)

train

# Commented out IPython magic to ensure Python compatibility.
# %%time
# 
# model = LinearRegression()
# model = model.fit(features_train, target_train)
# predictions_valid = model.predict(features_valid)
# mse = mean_squared_error(target_valid, predictions_valid)
# print("MSE:", mse)
# rmse = mse ** 0.5 
# print("RMSE:", rmse)

targetv1= pd.DataFrame(target_valid)
targetv1['predictions_valid'] = predictions_valid

targetv1.plot( color=['red', 'blue'], figsize=(15,8))
# Add Title and Labels
plt.title('')
plt.xlabel('Days')
plt.ylabel('values')

# Commented out IPython magic to ensure Python compatibility.
# %%time
# model1 = CatBoostRegressor(iterations=100, learning_rate=0.5, depth = 8)
# # Fit model
# model1.fit(features_train, target_train, verbose=10) 
# predictions_valid1 = model1.predict(features_valid)
# mse1 = mean_squared_error(target_valid, predictions_valid1)
# print("MSE:", mse1)
# rmse1 = mse1 ** 0.5 
# print("RMSE:", rmse1)

targetv2= pd.DataFrame(target_valid)
targetv2['predictions_valid1'] = predictions_valid1

targetv2.plot( color=['red', 'blue'], figsize=(15,8))
# Add Title and Labels
plt.title('')
plt.xlabel('Days')
plt.ylabel('values')

# Commented out IPython magic to ensure Python compatibility.
# %%time
# model4 = RandomForestRegressor(n_estimators=100, max_depth = 13)
# model4.fit(features_train, target_train) 
# predictions_valid4 = model4.predict(features_valid)
# mse4 = mean_squared_error(target_valid, predictions_valid4)
# print("MSE:", mse4)
# rmse4 = mse4 ** 0.5 
# print("RMSE:", rmse4)

targetv= pd.DataFrame(target_valid)
targetv['predictions_valid4'] = predictions_valid4

targetv.plot( color=['red', 'blue'], figsize=(15,8))
# Add Title and Labels
plt.title('')
plt.xlabel('Days')
plt.ylabel('values')

# Commented out IPython magic to ensure Python compatibility.
# %%time
# predictions_test = model1.predict(features_test)
# mse1 = mean_squared_error(target_test, predictions_test)
# print("MSE:", mse1)
# rmse1 = mse1 ** 0.5 
# print("RMSE:", rmse1)

fin= pd.DataFrame(target_test)
fin['predictions_test'] = predictions_test

fin.plot( color=['red', 'blue'], figsize=(15,8))
# Add Title and Labels
plt.title('')
plt.xlabel('Days')
plt.ylabel('values')

fin

plt.figure(figsize=(15, 5))
plt.ylim([7.6, 11])
plt.plot(data_split.index, data_split.y, label = "line 1")
plt.plot(fin.index, fin.predictions_test, label= "line 2")
plt.legend()
plt.show()